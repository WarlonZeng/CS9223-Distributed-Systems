// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "KVStore.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <thrift/transport/TTransportUtils.h>

#include <typeinfo>

#include <map>
#include <string>
#include <iostream>
#include <stdexcept>
#include <sstream>
#include <iterator>
#include <algorithm>
#include <utility>
#include <functional>

#include <stdio.h>       // perror, snprintf
#include <stdlib.h>      // exit
#include <unistd.h>      // close, write
#include <string.h>      // strlen
#include <strings.h>     // bzero
#include <time.h>        // time, ctime
#include <sys/socket.h>  // socket, AF_INET, SOCK_STREAM, bind, listen, accept
#include <netinet/in.h>  // servaddr, INADDR_ANY, htons
#include <thread>

#define	MAXLINE		4096	// max text line length
#define	BUFFSIZE	8192    // buffer size for reads and writes
#define  SA struct sockaddr
#define	LISTENQ		1024	// 2nd argument to listen()
#define PORT_NUM        13002

using namespace apache::thrift;
using namespace apache::thrift::concurrency;
using namespace apache::thrift::protocol;
using namespace apache::thrift::transport;
using namespace apache::thrift::server;

// using namespace boost::shared_ptr; // boost and std should be linked-in
// using namespace boost; /// bad practice?

//using namespace std; // bad practice?
using namespace kvstore;

class KVStoreHandler : virtual public KVStoreIf {
  // I will use a map for this job. 
  std::map<std::string, std::string> kvstore;
 public:
  KVStoreHandler() {}

  void kvset(Result& _return, const std::string& key, const std::string& value) {
    // Store the value. This will replace any previous key-value store.
    kvstore[key] = value;

    // Checking if we actually stored the value or not by counting number of instances
    // If true, return kSuccess
    // If false, return kError
    if (kvstore.count(key) > 0) {
      _return.error = ErrorCode::kSuccess;
      _return.value = value;
    }
    else {
      _return.error = ErrorCode::kError;
      _return.errortext = "Server could not store value";
    }

    printf("kvset\n");
    //cout << key << ": " << kvstore[key] << endl;
  }

  void kvget(Result& _return, const std::string& key) {
    // Checking if the key is in the map or not by counting number of instances
    // If true, return value and kSuccess
    // If false, return kKeyNotFound
    if (kvstore.count(key) > 0) {
      _return.value = kvstore[key];
      _return.error = ErrorCode::kSuccess;
    }
    else
      _return.error = ErrorCode::kKeyNotFound;

    printf("kvget\n");
    //cout << key << ": " << kvstore[key] << endl;
  }

  void kvdelete(Result& _return, const std::string& key) {
    // Checking if the key is in the map or not by counting number of instances
    // If true, delete it and return kSuccess
    // If false, return kKeyNotFound
    if (kvstore.count(key) > 0) {
      kvstore.erase(key); // Delete it
      if (kvstore.count(key) > 0) { // Check if it is actually deleted
        _return.error = ErrorCode::kError;
        _return.errortext = "Server could not delete key-value pair";
      }
      else
        _return.error = ErrorCode::kSuccess;
    }
    else
      _return.error = ErrorCode::kKeyNotFound;
  

    printf("kvdelete\n");
    //cout << key << ": " << kvstore[key] << endl;
  }

};

int main(int argc, char **argv) {
  int port = 9090;
  boost::shared_ptr<KVStoreHandler> handler(new KVStoreHandler());
  boost::shared_ptr<TProcessor> processor(new KVStoreProcessor(handler));
  boost::shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  boost::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  boost::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  std::cout << "Starting the server..." << std::endl;
  server.serve();
  std::cout << "Done." << std::endl;
  return 0;
}