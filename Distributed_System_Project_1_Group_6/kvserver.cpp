// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include <thrift/concurrency/ThreadManager.h>
#include <thrift/concurrency/PlatformThreadFactory.h>
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/server/TThreadPoolServer.h>
#include <thrift/server/TThreadedServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TSocket.h>
#include <thrift/transport/TTransportUtils.h>
#include <thrift/TToString.h>

#include <boost/make_shared.hpp>

#include <typeinfo>

#include <map>
#include <string>
#include <iostream>
#include <stdexcept>
#include <sstream>
#include <iterator>
#include <algorithm>
#include <utility>
#include <functional>

#include <stdio.h>       // perror, snprintf
#include <stdlib.h>      // exit
#include <unistd.h>      // close, write
#include <string.h>      // strlen
#include <strings.h>     // bzero
#include <time.h>        // time, ctime
#include <sys/socket.h>  // socket, AF_INET, SOCK_STREAM, bind, listen, accept
#include <netinet/in.h>  // servaddr, INADDR_ANY, htons
#include <thread>

#include "KVStore.h"

#define	MAXLINE		4096	// max text line length
#define	BUFFSIZE	8192    // buffer size for reads and writes
#define	LISTENQ		1024	// 2nd argument to listen()
#define PORT_NUM  13002
#define SA struct sockaddr

using namespace apache::thrift;
using namespace apache::thrift::concurrency;
using namespace apache::thrift::protocol;
using namespace apache::thrift::transport;
using namespace apache::thrift::server;

// using namespace boost::shared_ptr; // boost and std should be linked-in
// using namespace boost; /// bad practice?

//using namespace std; // bad practice?
using namespace kvstore;

// I will use a map for this job. 
std::map<std::string, std::string> shared_kvstore;

class KVStoreHandler : virtual public KVStoreIf {

 public:
  KVStoreHandler() {}

  void kvset(Result& _return, const std::string& key, const std::string& value) {
    // Store the value. This will replace any previous key-value store.
    shared_kvstore[key] = value;

    // Checking if we actually stored the value or not by counting number of instances
    // If true, return kSuccess
    // If false, return kError
    if (shared_kvstore.count(key) > 0) {
      _return.error = ErrorCode::kSuccess;
      _return.value = value;
    }
    else {
      _return.error = ErrorCode::kError;
      _return.errortext = "Server could not store value";
    }

    printf("kvset\n");
    //cout << key << ": " << shared_kvstore[key] << endl;
  }

  void kvget(Result& _return, const std::string& key) {
    // Checking if the key is in the map or not by counting number of instances
    // If true, return value and kSuccess
    // If false, return kKeyNotFound
    if (shared_kvstore.count(key) > 0) {
      _return.value = shared_kvstore[key];
      _return.error = ErrorCode::kSuccess;
    }
    else
      _return.error = ErrorCode::kKeyNotFound;

    printf("kvget\n");
    //cout << key << ": " << shared_kvstore[key] << endl;
  }

  void kvdelete(Result& _return, const std::string& key) {
    // Checking if the key is in the map or not by counting number of instances
    // If true, delete it and return kSuccess
    // If false, return kKeyNotFound
    if (shared_kvstore.count(key) > 0) {
      shared_kvstore.erase(key); // Delete it
      if (shared_kvstore.count(key) > 0) { // Check if it is actually deleted
        _return.error = ErrorCode::kError;
        _return.errortext = "Server could not delete key-value pair";
      }
      else
        _return.error = ErrorCode::kSuccess;
    }
    else
      _return.error = ErrorCode::kKeyNotFound;
  

    printf("kvdelete\n");
    //cout << key << ": " << shared_kvstore[key] << endl;
  }

};


// Enable thread pooling (concurrency)
class KVStoreCloneFactory : virtual public KVStoreIfFactory {
 public:
  virtual ~KVStoreCloneFactory() {}
  virtual KVStoreIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) {
    boost::shared_ptr<TSocket> sock = boost::dynamic_pointer_cast<TSocket>(connInfo.transport);
    std::cout << "Incoming connection\n";
    std::cout << "\tSocketInfo: "  << sock->getSocketInfo() << "\n";
    std::cout << "\tPeerHost: "    << sock->getPeerHost() << "\n";
    std::cout << "\tPeerAddress: " << sock->getPeerAddress() << "\n";
    std::cout << "\tPeerPort: "    << sock->getPeerPort() << "\n";
    return new KVStoreHandler;
  }
  virtual void releaseHandler( KVStoreIf* handler) {
    delete handler;
  }
};


int main(int argc, char **argv) {
  int port = 9090;
  TThreadedServer server(
    boost::make_shared<KVStoreProcessorFactory>(boost::make_shared<KVStoreCloneFactory>()),
    boost::make_shared<TServerSocket>(port), //port
    boost::make_shared<TBufferedTransportFactory>(),
    boost::make_shared<TBinaryProtocolFactory>()
  );

  std::cout << "Starting the server..." << std::endl;
  server.serve();
  std::cout << "Done." << std::endl;
  return 0;

}