// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "KVStore.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <thrift/transport/TTransportUtils.h>
#include <map>
#include <string>
#include <iostream>
#include <iterator>
#include <algorithm>
#include <utility>
#include <functional>
#include <sstream>

using namespace apache::thrift;
using namespace apache::thrift::protocol;
using namespace apache::thrift::transport;
using namespace apache::thrift::server;

using boost::shared_ptr;

using namespace std;
using namespace kvstore;

class KVStoreHandler : virtual public KVStoreIf {
  // I will use a map for this job. 
  map<string, string> kvstore;
 public:
  KVStoreHandler() {}

  void kvset(Result& _return, const std::string& key, const std::string& value) {
    // Store the value. This will replace any previous key-value store.
    kvstore[key] = value;

    // Checking if we actually stored the value or not by counting number of instances
    // If true, return kSuccess
    // If false, return kError
    if (kvstore.count(key) > 0) {
      _return.error = ErrorCode::kSuccess;
      _return.value = value;
    }
    else {
      _return.error = ErrorCode::kError;
      _return.errortext = "Server could not store value";
    }

    printf("kvset\n");
    //cout << key << ": " << kvstore[key] << endl;
  }

  void kvget(Result& _return, const std::string& key) {
    // Checking if the key is in the map or not by counting number of instances
    // If true, return value and kSuccess
    // If false, return kKeyNotFound
    if (kvstore.count(key) > 0) {
      _return.value = kvstore[key];
      _return.error = ErrorCode::kSuccess;
    }
    else
      _return.error = ErrorCode::kKeyNotFound;

    printf("kvget\n");
    //cout << key << ": " << kvstore[key] << endl;
  }

  void kvdelete(Result& _return, const std::string& key) {
    // Checking if the key is in the map or not by counting number of instances
    // If true, delete it and return kSuccess
    // If false, return kKeyNotFound
    if (kvstore.count(key) > 0) {
      kvstore.erase(key); // Delete it
      if (kvstore.count(key) > 0) { // Check if it is actually deleted
        _return.error = ErrorCode::kError;
        _return.errortext = "Server could not delete key-value pair";
      }
      else
        _return.error = ErrorCode::kSuccess;
    }
    else
      _return.error = ErrorCode::kKeyNotFound;
  

    printf("kvdelete\n");
    //cout << key << ": " << kvstore[key] << endl;
  }
};




int main(int argc, char **argv) {
  int port = 9090;
  //shared_ptr<KVStoreHandler> handler(new KVStoreHandler());
  //shared_ptr<TProcessor> processor(new KVStoreProcessor(handler));
  //shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  //shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  //shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  //TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  



  cout << "Starting the server..." << endl;
  server.serve();
  cout << "Done." << endl;
  return 0;
}